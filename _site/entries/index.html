<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
<title>JSONAPI Suite</title>
<meta name="viewport" content="width=device-width">
<meta name="author" content="">
<link rel="stylesheet" href="/css/main.css">
<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:500,600' rel='stylesheet' type='text/css'>

    </head>

    <body>
        <div class="container">
            <div class="overview">
                <span class="toggle">close</span>
                <header>
  <span>JSONAPI Suite</span>
</header>

                <ul id="nav">
    
    
    <li  class="parent current">
        <a href="#intro">Introduction</a>
        
            <ul>
                
                
                    <li >
                        <a href="#features">Features</a>
                        
                    </li>
                
            </ul>
        
    </li>
    
    <li >
        <a href="#installation">Installation</a>
        
    </li>
    
    <li  class="parent">
        <a href="#reads">Reads</a>
        
            <ul>
                
                
                    <li >
                        <a href="#basics">The Basics</a>
                        
                    </li>
                
                    <li >
                        <a href="#filtering">Filtering</a>
                        
                    </li>
                
                    <li >
                        <a href="#includes">Includes</a>
                        
                    </li>
                
            </ul>
        
    </li>
    
    <li  class="parent">
        <a href="#writes">Writes</a>
        
            <ul>
                
                
                    <li >
                        <a href="#deserialization">Deserialization</a>
                        
                    </li>
                
                    <li >
                        <a href="#validations">Validations</a>
                        
                    </li>
                
                    <li >
                        <a href="#strong_resources">Strong Resources</a>
                        
                    </li>
                
            </ul>
        
    </li>
    
    <li >
        <a href="#error-handling">Error Handling</a>
        
    </li>
    
    <li >
        <a href="#spec-helpers">Spec Helpers</a>
        
    </li>
    
    <li >
        <a href="#swagger">Swagger</a>
        
    </li>
    
    <li >
        <a href="#jsonapi-plus">JSON API Plus</a>
        
    </li>
    
</ul>
            </div>

            <div class="content">
                <span class="toggle">open</span>
                


    
        <section id="intro" class="h1">
            
                  <h1><a href="#intro" name="intro">Introduction</a></h1>
                

            <p>Welcome to JSONAPI Suite! This gem is a collection of libraries to
enabled quick and easy <a href="http://jsonapi.org">jsonapi.org</a>-compatible APIs
with <a href="http://rubyonrails.org">Ruby on Rails</a>.</p>

<p>If you only have 5 seconds to look at this, we recommend you take a
glance at <a href="#basics">The Basics</a>.</p>

        </section>
    

    
        <section id="features" class="h2">
            
                  <h2><a href="#features" name="features">Features</a></h2>
                

            <p>Todo: corresponding libs for ember, ruby client</p>

<ul>
  <li>Get pagination, sorting, and sparse fieldsets for free.</li>
  <li>Simple, flexible DSL for providing filters.</li>
  <li>Whitelist available <code class="highlighter-rouge">?include</code> paramters.</li>
  <li>Support for nested relations in POST and PUT requests.</li>
  <li>Works with any ORM, not just ActiveRecord.</li>
  <li>Global error handling <a href="http://jsonapi.org/format/#errors">compatible with the spec</a>.</li>
  <li>Tries to match vanilla Rails as closely as possible.</li>
  <li>Spec helpers to make integration testing simple and effective.</li>
  <li>Automatically document your API with <a href="http://swagger.io">swagger</a>.</li>
  <li>Type-checking of incoming payloads.</li>
  <li>…and more!</li>
</ul>

        </section>
    

    
        <section id="installation" class="h1">
            
                  <h1><a href="#installation" name="installation">Installation</a></h1>
                

            <p>To get up and running, we need to install the gem and include a few
modules.</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="c1"># Gemfile</span>
<span class="n">gem</span> <span class="s1">'jsonapi_suite'</span>

<span class="c1"># app/controllers/application_controller.rb</span>
<span class="k">class</span> <span class="nc">ApplicationController</span> <span class="o">&lt;</span> <span class="no">ActionController</span><span class="o">::</span><span class="no">API</span>
  <span class="kp">include</span> <span class="no">JsonapiSuite</span><span class="o">::</span><span class="no">ControllerMixin</span>
<span class="k">end</span>

<span class="c1"># create app/serializers/application_serializer.rb</span>
<span class="k">class</span> <span class="nc">ApplicationSerializer</span> <span class="o">&lt;</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">Serializer</span>
  <span class="kp">include</span> <span class="no">JsonapiAmsExtensions</span>
<span class="k">end</span>
</code></pre>
</div>

<p>In addition, this suite depends on <a href="github.com/rails-api/active_model_serializers">active_model_serializers</a>. However, to accomodate a <a href="https://github.com/rails-api/active_model_serializers/pull/1797">performance issue</a>, we currently suggest you run off of this fork:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">gem</span> <span class="s1">'active_model_serializers'</span><span class="p">,</span>
  <span class="ss">git: </span><span class="s1">'https://github.com/richmolj/active_model_serializers.git'</span>
</code></pre>
</div>

<p>While not a requirement, you can get out-of-the-box pagination with any
gem that adds <code class="highlighter-rouge">per</code> and <code class="highlighter-rouge">page</code> methods to your ActiveRecord scopes. We
recommend <code class="highlighter-rouge">kamanari</code>:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="c1"># Gemfile</span>
<span class="n">gem</span> <span class="s1">'kaminari'</span>
</code></pre>
</div>

<p>You’re ready to go!</p>

<p>todo: seed, model, migrate in subsection</p>

<p>todo: note activerecord not dependency, just example</p>

        </section>
    

    
        <section id="reads" class="h1">
            
                  <h1><a href="#reads" name="reads">Reads</a></h1>
                

            

        </section>
    

    
        <section id="basics" class="h2">
            
                  <h2><a href="#basics" name="basics">The Basics</a></h2>
                

            <p>Let’s write a very simple controller:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">EmployeesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="n">jsonapi</span> <span class="p">{</span> <span class="p">}</span>

  <span class="k">def</span> <span class="nf">index</span>
    <span class="n">employees</span> <span class="o">=</span> <span class="no">Employee</span><span class="p">.</span><span class="nf">all</span>
    <span class="n">render_ams</span><span class="p">(</span><span class="n">employees</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>The above controller automatically supports:</p>

<ul>
  <li><a href="http://jsonapi.org/format/#fetching-pagination">Pagination</a></li>
  <li><a href="http://jsonapi.org/format/#fetching-sorting">Sorting</a></li>
  <li><a href="http://jsonapi.org/format/#fetching-sparse-fieldsets">Sparse Fieldsets</a></li>
  <li>A <a href="http://jsonapi.org/format/#document-structure">jsonapi.org compatible response</a></li>
</ul>

<p>Let’s take a look at what this code does.</p>

<p><code class="highlighter-rouge">jsonapi { }</code> sets up our controller. We’ll go into this in more detail
later.</p>

<p><code class="highlighter-rouge">render_ams</code> is similar to <code class="highlighter-rouge">render :json</code>. However, it’s going to do
some extra work for you. For starters, it will pass relavant arguments -
like which sparse fieldsets were requested - to <code class="highlighter-rouge">render</code> for you.</p>

<p><code class="highlighter-rouge">render_ams</code> will also build the appropriate query scope. In this case
we passed it an ActiveRecord scope (<code class="highlighter-rouge">Employee.all</code>) that can be chained
off of. In this case we’re automatically adding pagination, sorting, and
<code class="highlighter-rouge">select</code> to that scope.</p>

<p>This means you could optionally provide a default scope:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">index</span>
  <span class="n">employees</span> <span class="o">=</span> <span class="no">Employee</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">active: </span><span class="kp">true</span><span class="p">)</span>
  <span class="n">render_ams</span><span class="p">(</span><span class="n">employees</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>If you want to lower-level access to the scope we’re building, use
<code class="highlighter-rouge">jsonapi_scope</code>. The following is equivalent:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">index</span>
  <span class="n">scope</span> <span class="o">=</span> <span class="n">jsonapi_scope</span><span class="p">(</span><span class="no">Employee</span><span class="p">.</span><span class="nf">all</span><span class="p">)</span>
  <span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">active: </span><span class="kp">true</span><span class="p">)</span>

  <span class="c1"># Here we'll pass the actual records instead of</span>
  <span class="c1"># a scope, the scoping logic has already fired.</span>
  <span class="n">render_ams</span><span class="p">(</span><span class="n">scope</span><span class="p">.</span><span class="nf">to_a</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

        </section>
    

    
        <section id="filtering" class="h2">
            
                  <h2><a href="#filtering" name="filtering">Filtering</a></h2>
                

            <p>Let’s have some fun implementing <a href="http://jsonapi.org/format/#fetching-filtering">filtering</a>.</p>

<p>Assume we’re using ActiveRecord and want to filter records based on name
and email:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">EmployeesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="n">jsonapi</span> <span class="k">do</span>
    <span class="n">allow_filter</span> <span class="ss">:name</span>
    <span class="n">allow_filter</span> <span class="ss">:email</span>
  <span class="k">end</span>
  <span class="c1"># ... code ...</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Congratulations! You can now filter on name, email, or both. In other
words, these URLs now work:</p>

<ul>
  <li><code class="highlighter-rouge">/api/employees?filter[name]=Homer</code></li>
  <li><code class="highlighter-rouge">/api/employees?filter[email]=chunkylover53@hotmail.com</code></li>
  <li><code class="highlighter-rouge">/api/employees?filter[name]=Homer&amp;email=chunkylover53@hotmail.com</code></li>
</ul>

<p>What if you want to filter on something that’s not an attribute, like
all names starting with ‘hom’? Simply pass a block to <code class="highlighter-rouge">allow_filter</code> and
chain onto your scope:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">allow_filter</span> <span class="ss">:name_prefix</span> <span class="k">do</span> <span class="o">|</span><span class="n">scope</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
  <span class="n">scope</span><span class="p">.</span><span class="nf">where</span><span class="p">([</span><span class="s2">"name LIKE ?"</span><span class="p">,</span> <span class="s2">"</span><span class="si">#{</span><span class="n">value</span><span class="si">}</span><span class="s2">%"</span><span class="p">])</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Or maybe we’re using <a href="https://github.com/mbleigh/acts-as-taggable-on">acts_as_taggable_on</a> and want to find all employees with a given tag:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">allow_filter</span> <span class="ss">:tag</span> <span class="k">do</span> <span class="o">|</span><span class="n">scope</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
  <span class="n">scope</span><span class="p">.</span><span class="nf">tagged_with</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="ss">any: </span><span class="kp">true</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Filters can be conditional as well. Let’s say we want to allow filtering
on <code class="highlighter-rouge">salary</code> if the user is an admin:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">allow_filter</span> <span class="ss">:salary</span><span class="p">,</span> <span class="ss">if: :admin?</span>

<span class="c1"># ... code ...</span>

<span class="k">def</span> <span class="nf">admin?</span>
  <span class="n">current_user</span><span class="p">.</span><span class="nf">role</span> <span class="o">==</span> <span class="s1">'admin'</span>
<span class="k">end</span>
</code></pre>
</div>

        </section>
    

    
        <section id="includes" class="h2">
            
                  <h2><a href="#includes" name="includes">Includes</a></h2>
                

            <p><a href="http://jsonapi.org/format/#fetching-includes">Inclusion of related resources</a> (<em>‘sideloading’</em>) is critical to JSON API. We need to do three things to support this feature:</p>

<ul>
  <li>Render the requested resources in <code class="highlighter-rouge">included</code>.</li>
  <li>Make sure our ORM eager loads all relationships to avoid N+1 issues.</li>
  <li>Whitelist certain includes. You probably don’t want to expose your
entire object graph, for both performance and security concerns.</li>
</ul>

<p>The suite will handle this for you. Just add a whitelist:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">jsonapi</span> <span class="k">do</span>
  <span class="n">includes</span> <span class="ss">whitelist: </span><span class="p">{</span> <span class="ss">index: </span><span class="s1">'tags'</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>

<p>No other code changes are required. Our endpoint now supports
<code class="highlighter-rouge">/api/employees?include=tags</code>, putting all <code class="highlighter-rouge">Tag</code> resources in <code class="highlighter-rouge">included</code>. Any resources requested that have not been whitelisted will be silently dropped.</p>

<p>Nesting includes is also supported:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">jsonapi</span> <span class="k">do</span>
  <span class="n">includes</span> <span class="ss">whitelist: </span><span class="p">{</span> <span class="ss">index: </span><span class="p">[</span><span class="s1">'tags'</span><span class="p">,</span> <span class="p">{</span> <span class="ss">department: </span><span class="s1">'goals'</span> <span class="p">}]</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Would support the endpoint
<code class="highlighter-rouge">/api/employees?include=tags,department.goals</code>. This is why the
whitelist is a hash - you may want to limit the whitelist for <code class="highlighter-rouge">index</code>
for performance reasons:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">jsonapi</span> <span class="k">do</span>
  <span class="n">includes</span> <span class="ss">whitelist: </span><span class="p">{</span>
    <span class="ss">index: :department</span><span class="p">,</span>
    <span class="ss">show: </span><span class="p">[</span><span class="s1">'tags'</span><span class="p">,</span> <span class="p">{</span> <span class="ss">department: </span><span class="s1">'goals'</span> <span class="p">}]</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>

<div class="note info">
  <h6 id="ensure-your-serializer-specifies-relationships">Ensure your serializer specifies relationships</h6>
  <div class="note-content">
    <p>The above code assumes relationships are specified in your serializers
  as well. Our <code class="highlighter-rouge">EmployeeSerializer</code> would need:</p>

    <div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">belongs_to</span> <span class="ss">:department</span>
<span class="n">has_many</span> <span class="ss">:tags</span>
</code></pre>
    </div>
  </div>
</div>

        </section>
    

    
        <section id="deserialization" class="h2">
            
                  <h2><a href="#deserialization" name="deserialization">Deserialization</a></h2>
                

            <p>By default, Rails doesn’t work too well with incoming JSON API payloads.
You can fix that with <code class="highlighter-rouge">deserialize_jsonapi!</code>:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">before_action</span> <span class="ss">:deserialize_jsonapi!</span><span class="p">,</span> <span class="ss">only: </span><span class="p">[</span><span class="ss">:create</span><span class="p">,</span> <span class="ss">:update</span><span class="p">]</span>
</code></pre>
</div>

<p>This will transform params from this:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="c1"># POST /employees</span>
<span class="p">{</span>
  <span class="ss">data: </span><span class="p">{</span>
    <span class="ss">type: </span><span class="s1">'employees'</span><span class="p">,</span>
    <span class="ss">attributes: </span><span class="p">{</span> <span class="ss">name: </span><span class="s1">'Homer Simpson'</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>To this:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="p">{</span>
  <span class="ss">employee: </span><span class="p">{</span>
    <span class="ss">name: </span><span class="s1">'Homer Simpson'</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>As if it were vanilla Rails. This will also transform any relationships
into an <a href="http://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html">accepts_nested_attributes_for</a>-compatible payload:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="c1"># POST /employees</span>
<span class="p">{</span>
  <span class="ss">data: </span><span class="p">{</span>
    <span class="ss">type: </span><span class="s1">'employees'</span><span class="p">,</span>
    <span class="ss">attributes: </span><span class="p">{</span> <span class="ss">name: </span><span class="s1">'Homer Simpson'</span> <span class="p">},</span>
    <span class="ss">relationships: </span><span class="p">{</span>
      <span class="ss">department: </span><span class="p">{</span>
        <span class="ss">data: </span><span class="p">{</span>
          <span class="ss">type: </span><span class="s1">'departments'</span><span class="p">,</span>
          <span class="ss">attributes: </span><span class="p">{</span> <span class="ss">name: </span><span class="s1">'Safety'</span> <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Becomes:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="p">{</span>
  <span class="ss">employee: </span><span class="p">{</span>
    <span class="ss">name: </span><span class="s1">'Homer Simpson'</span><span class="p">,</span>
    <span class="ss">department_attributes: </span><span class="p">{</span>
      <span class="p">{</span> <span class="ss">name: </span><span class="s1">'Safety'</span> <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

        </section>
    

    
        <section id="writes" class="h1">
            
                  <h1><a href="#writes" name="writes">Writes</a></h1>
                

            

        </section>
    

    
        <section id="validations" class="h2">
            
                  <h2><a href="#validations" name="validations">Validations</a></h2>
                

            <p>If our model has a validation error, we need to render a <a href="http://jsonapi.org/format/#errors">JSON API Error
Object</a>. You can just use
<code class="highlighter-rouge">render_errors_for</code> and forget about it:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">create</span>
  <span class="n">employee</span> <span class="o">=</span> <span class="no">Employee</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">employee_params</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">employee</span><span class="p">.</span><span class="nf">save</span>
    <span class="n">render_ams</span><span class="p">(</span><span class="n">employee</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="n">render_errors_for</span><span class="p">(</span><span class="n">employee</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Would output a <code class="highlighter-rouge">422</code> response code with something like:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="p">{</span>
  <span class="ss">errors: </span><span class="p">[</span>
    <span class="p">{</span>
      <span class="ss">code: </span><span class="s1">'unprocessable_entity'</span><span class="p">,</span>
      <span class="ss">status: </span><span class="s1">'422'</span><span class="p">,</span>
      <span class="ss">title: </span><span class="s1">'Validation Error'</span><span class="p">,</span>
      <span class="ss">detail: </span><span class="s2">"Name can't be blank"</span><span class="p">,</span>
      <span class="ss">source: </span><span class="p">{</span> <span class="ss">pointer: </span><span class="s1">'/data/attributes/name'</span> <span class="p">},</span>
      <span class="ss">meta: </span><span class="p">{</span>
        <span class="ss">attribute: :name</span><span class="p">,</span>
        <span class="ss">message: </span><span class="s2">"can't be blank"</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</code></pre>
</div>

        </section>
    

    
        <section id="strong_resources" class="h2">
            
                  <h2><a href="#strong_resources" name="strong_resources">Strong Resources</a></h2>
                

            <p>At this point we <strong>could</strong> use regular ol’ <a href="https://github.com/rails/strong_parameters">strong_parameters</a>. That would work. However, two things eventually crop up making this a pain point:</p>

<ul>
  <li>You end up typing essentially the same stuff when writing your
<a href="http://swagger.io">swagger</a> documentation, which violates the DRY
principle and leads to code and documentation getting out of sync.</li>
  <li>If your API endpoints accept nested resources, you end up typing the
same nested resource attributes across multiple controllers,
inevitably adding an attribute it one place but forgetting it in others.</li>
</ul>

<p>Enter Strong Resources - DRY strong parameters! Instead of code like
this:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">employee_params</span>
  <span class="n">params</span><span class="p">.</span><span class="nf">require</span><span class="p">(</span><span class="ss">:employee</span><span class="p">).</span><span class="nf">permit</span> <span class="p">\</span>
    <span class="ss">:name</span><span class="p">,</span>
    <span class="ss">:email</span><span class="p">,</span>
    <span class="ss">department_attributes: </span><span class="p">[</span><span class="ss">:name</span><span class="p">]</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Write this:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="c1"># config/initializers/strong_resources.rb</span>
<span class="no">StrongResources</span><span class="p">.</span><span class="nf">configure</span> <span class="k">do</span>
  <span class="n">strong_resource</span> <span class="ss">:employee</span> <span class="k">do</span>
    <span class="n">attribute</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:string</span>
    <span class="n">attribute</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:string</span>
  <span class="k">end</span>

  <span class="n">strong_resource</span> <span class="ss">:department</span> <span class="k">do</span>
    <span class="n">attribute</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:string</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># app/controllers/employees_controller.rb</span>
<span class="k">class</span> <span class="nc">EmployeesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="n">jsonapi</span> <span class="p">{</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span><span class="nf">code</span><span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="p">}</span>

  <span class="n">strong_resource</span> <span class="ss">:employee</span> <span class="k">do</span>
    <span class="n">belongs_to</span> <span class="ss">:department</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># app/controllers/departments_controller.rb</span>
<span class="k">class</span> <span class="nc">DepartmentsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="n">strong_resource</span> <span class="ss">:department</span>
<span class="k">end</span>
</code></pre>
</div>

<p>We’re defining our resource payloads only once, all in
<code class="highlighter-rouge">config/initializers/strong_resources</code>, then referencing those payloads
in each controller. We’ll be able to reference this same metadata when
auto-documenting our API in swagger.</p>

<p>Since this gem uses <a href="https://github.com/zendesk/stronger_parameters">stronger_parameters</a> underneath the hood, we also get free type checking and type casting. For instance passing a <code class="highlighter-rouge">Time</code> for the <code class="highlighter-rouge">name</code> attribute would raise <code class="highlighter-rouge">StrongerParameters::InvalidParameter</code>.</p>

<p>You can also register custom types:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">Parameters</span> <span class="o">=</span> <span class="no">ActionController</span><span class="o">::</span><span class="no">Parameters</span>
<span class="n">strong_param</span> <span class="ss">:department_enum</span><span class="p">,</span>
  <span class="ss">swagger: :string</span><span class="p">,</span> <span class="c1"># the corresponding swagger type</span>
  <span class="ss">type: </span><span class="no">Parameters</span><span class="p">.</span><span class="nf">enum</span><span class="p">(</span><span class="s1">'Safety'</span><span class="p">,</span> <span class="s1">'Sales'</span><span class="p">,</span> <span class="s1">'Accounting'</span><span class="p">)</span>

<span class="n">strong_resource</span> <span class="ss">:department</span> <span class="k">do</span>
  <span class="n">attribute</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:department_enum</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Would throw a <code class="highlighter-rouge">StrongerParameters::InvalidParameter</code> when passing a
department name that is not ‘Safety’, ‘Sales’, or ‘Accounting’.</p>

<p>Attributes can be conditional as well:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">strong_resource</span> <span class="ss">:employee</span> <span class="k">do</span>
  <span class="n">attribute</span> <span class="ss">:salary</span><span class="p">,</span> <span class="ss">:integer</span><span class="p">,</span> <span class="ss">if: </span><span class="o">-&gt;</span><span class="p">(</span><span class="n">controller</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">controller</span><span class="p">.</span><span class="nf">current_user</span><span class="p">.</span><span class="nf">admin?</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>

<p>For documentation on the various things you can do with
<code class="highlighter-rouge">strong_resources</code>, view the documentation for that project:</p>

<p>Todo: link</p>

        </section>
    

    
        <section id="error-handling" class="h1">
            
                  <h1><a href="#error-handling" name="error-handling">Error Handling</a></h1>
                

            <p>We touched on <a href="http://jsonapi.org/format/#errors">Error Objects</a> in the
<a href="/entries#validations">validations section</a>. Let’s make this work for
any random error our application might throw:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ApplicationController</span> <span class="o">&lt;</span> <span class="no">ActionController</span><span class="o">::</span><span class="no">API</span>
  <span class="c1"># ... code ...</span>

  <span class="n">rescue_from</span> <span class="no">Exception</span> <span class="k">do</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span>
    <span class="n">handle_exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Now let’s say we had <code class="highlighter-rouge">raise 'foo'</code> somewhere. Our API would return a 500
status code with:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="p">{</span>
  <span class="ss">errors: </span><span class="p">[</span>
    <span class="ss">code: </span><span class="s1">'internal_server_error'</span><span class="p">,</span>
    <span class="ss">status: </span><span class="s1">'500'</span><span class="p">,</span>
    <span class="ss">title: </span><span class="s1">'Error'</span><span class="p">,</span>
    <span class="ss">detail: </span><span class="s2">"We've notified our engineers and hope to address this issue shortly."</span><span class="p">,</span>
    <span class="ss">meta: </span><span class="p">{}</span>
  <span class="p">]</span>
<span class="p">}</span>
</code></pre>
</div>

<p>This can all be customized. Let’s say for all
<code class="highlighter-rouge">ActiveRecord::RecordNotFound</code> errors we want a 404 response code, with
the error <code class="highlighter-rouge">detail</code> providing a custom message:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">register_exception</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">RecordNotFound</span><span class="p">,</span>
  <span class="ss">status: </span><span class="mi">422</span><span class="p">,</span>
  <span class="ss">message: </span><span class="o">-&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="s2">"Couldn't find record with id </span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">id</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span>
</code></pre>
</div>

<p>Would output:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="p">{</span>
  <span class="ss">errors: </span><span class="p">[</span>
    <span class="ss">code: </span><span class="s1">'not_found'</span><span class="p">,</span>
    <span class="ss">status: </span><span class="s1">'404'</span><span class="p">,</span>
    <span class="ss">title: </span><span class="s1">'Error'</span><span class="p">,</span>
    <span class="ss">detail: </span><span class="s2">"Couldn't find record with id 123"</span><span class="p">,</span>
    <span class="ss">meta: </span><span class="p">{}</span>
  <span class="p">]</span>
<span class="p">}</span>
</code></pre>
</div>

<p>You can register exceptions in <code class="highlighter-rouge">ApplicationController</code>, or any subclass
if you want a specific controller to handle a given error differently.</p>

<p>For more customization options, see the <code class="highlighter-rouge">jsonapi_errorable</code> gem.</p>

<p>Todo link.</p>

        </section>
    

    
        <section id="spec-helpers" class="h1">
            
                  <h1><a href="#spec-helpers" name="spec-helpers">Spec Helpers</a></h1>
                

            <p>Validating verbose JSON API responses in tests can be a pain. We could
use something like <a href="https://github.com/thoughtbot/json_matchers">json_matchers</a> to validate a schema, but we hope to do one better - let’s validate full payloads with a few simple helpers, using full-stack <a href="https://github.com/rspec/rspec-rails#request-specs">rspec request specs</a>.</p>

<p>Let’s say we’re testing the <code class="highlighter-rouge">show</code> action of our employees controller, sideloading the employee’s department. Here’s vanilla RSpec of what the test might look like:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'rails_helper'</span>

<span class="no">RSpec</span><span class="p">.</span><span class="nf">describe</span> <span class="s1">'employees#show'</span><span class="p">,</span> <span class="ss">type: :request</span> <span class="k">do</span>
  <span class="n">let!</span><span class="p">(</span><span class="ss">:homer</span><span class="p">)</span>  <span class="p">{</span> <span class="no">Employee</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">name: </span><span class="s1">'Homer Simpson'</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">let!</span><span class="p">(</span><span class="ss">:safety</span><span class="p">)</span> <span class="p">{</span> <span class="n">employee</span><span class="p">.</span><span class="nf">create_department!</span><span class="p">(</span><span class="ss">name: </span><span class="s1">'Safety'</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">it</span> <span class="s1">'renders an employee, sideloading department'</span> <span class="k">do</span>
    <span class="n">get</span> <span class="s2">"/api/employees/</span><span class="si">#{</span><span class="n">homer</span><span class="p">.</span><span class="nf">id</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="ss">params: </span><span class="p">{</span>
      <span class="ss">include: </span><span class="s1">'department'</span>
    <span class="p">}</span>
    <span class="c1"># ... code asserting json response ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>To validate the response, we’ll call <code class="highlighter-rouge">assert_payload</code>:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">assert_payload</span><span class="p">(</span><span class="ss">:employee</span><span class="p">,</span> <span class="n">homer</span><span class="p">,</span> <span class="n">json_item</span><span class="p">)</span>
<span class="n">assert_payload</span><span class="p">(</span><span class="ss">:department</span><span class="p">,</span> <span class="n">safety</span><span class="p">,</span> <span class="n">json_include</span><span class="p">(</span><span class="s1">'departments'</span><span class="p">))</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">assert_payload</code> takes three arguments:</p>
<ul>
  <li>The name of a payload we’ve defined (we haven’t done this yet).</li>
  <li>The record we want to compare against</li>
  <li>The relevant slice of json. <code class="highlighter-rouge">json_item</code> and <code class="highlighter-rouge">json_includes</code> are
helpful methods to target the right slice. You can see all helpers in
the documentation for <code class="highlighter-rouge">jsonapi_spec_helpers</code>.</li>
</ul>

<p>OK, so we want to take a record, response JSON, and compare them against
something pre-defined. Let’s write those definitions; they look very similar to
something you’d write for <a href="https://github.com/thoughtbot/factory_girl">factory_girl</a>:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="c1"># spec/payloads/employee.rb</span>
<span class="no">JsonapiSpecHelpers</span><span class="o">::</span><span class="no">Payload</span><span class="p">.</span><span class="nf">register</span><span class="p">(</span><span class="ss">:employee</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">key</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span>
  <span class="n">key</span><span class="p">(</span><span class="ss">:email</span><span class="p">)</span>

  <span class="n">timestamps!</span>
<span class="k">end</span>

<span class="c1"># spec/payloads/department.rb</span>
<span class="no">JsonapiSpecHelpers</span><span class="o">::</span><span class="no">Payload</span><span class="p">.</span><span class="nf">register</span><span class="p">(</span><span class="ss">:department</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">key</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">assert_payload</code> will do four things:</p>

<ul>
  <li>Ensure keys that are not in the payload definition are <strong>not</strong> present.</li>
  <li>Ensure all keys in the registered payload <strong>are</strong> present.</li>
  <li>Ensures no value in a key/value pair is <code class="highlighter-rouge">nil</code> (this is overrideable).</li>
  <li>Ensures each key matches the expected record value. In other words,
we’re doing something like <code class="highlighter-rouge">expect(json['email']).to eq(homer.email)</code>.</li>
</ul>

<p>The comparison value can be customized. Let’s say we serialize the
<code class="highlighter-rouge">name</code> attribute as a combination of the employee’s <code class="highlighter-rouge">first_name</code> and
<code class="highlighter-rouge">last_name</code>:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">key</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">record</span><span class="o">|</span> <span class="s2">"</span><span class="si">#{</span><span class="n">record</span><span class="p">.</span><span class="nf">first_name</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">record</span><span class="p">.</span><span class="nf">last_name</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span>
</code></pre>
</div>

<p>You can also customize/override payloads at runtime in your test. Let’s
say we only serialize <code class="highlighter-rouge">salary</code> when the current user is an admin. Your
test could look something like:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">sign_in</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span>
<span class="n">assert_payload</span><span class="p">(</span><span class="ss">:employee</span><span class="p">,</span> <span class="n">homer</span><span class="p">,</span> <span class="n">json_item</span><span class="p">)</span>
<span class="n">sign_in</span><span class="p">(</span><span class="ss">:admin</span><span class="p">)</span>
<span class="n">assert_payload</span><span class="p">(</span><span class="ss">:employee</span><span class="p">,</span> <span class="n">homer</span><span class="p">,</span> <span class="n">json_item</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">key</span><span class="p">(</span><span class="ss">:salary</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>For documentation on all the spec helpers we provide, check out
<code class="highlighter-rouge">jsonapi_spec_helpers</code>.</p>

<p>Todo link.</p>

        </section>
    

    
        <section id="swagger" class="h1">
            
                  <h1><a href="#swagger" name="swagger">Swagger</a></h1>
                

            <p>OK, we now have DSLs for both reads (<code class="highlighter-rouge">jsonapi { }</code>) and writes
(<code class="highlighter-rouge">strong_resources</code>). That means we can introspect those DSLs to
auto-generate our documentation!</p>

<p>Note: I’m going to assume you already have <a href="http://swagger.io/swagger-ui">swagger-ui</a> set up, pointing to <code class="highlighter-rouge">/api/swagger_docs.json</code>.</p>

<p>We’re going to build on top of <a href="https://github.com/fotinakis/swagger-blocks">swagger-blocks</a>, so let’s go ahead and add our <code class="highlighter-rouge">DocsController</code>:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="c1"># config/routes</span>
<span class="n">scope</span> <span class="s1">'/api'</span> <span class="k">do</span>
  <span class="n">resources</span> <span class="ss">:docs</span><span class="p">,</span> <span class="ss">only: </span><span class="p">[</span><span class="ss">:index</span><span class="p">],</span> <span class="ss">path: </span><span class="s1">'/swagger_docs'</span>
<span class="k">end</span>

<span class="c1"># app/controllers/docs_controller.rb</span>
<span class="k">class</span> <span class="nc">DocsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="kp">include</span> <span class="no">JsonapiSwaggerHelpers</span><span class="o">::</span><span class="no">DocsControllerMixin</span>

  <span class="n">swagger_root</span> <span class="k">do</span>
    <span class="n">key</span> <span class="ss">:swagger</span><span class="p">,</span> <span class="s1">'2.0'</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Now add <code class="highlighter-rouge">jsonapi_resource</code> for any endpoint you want to document:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">jsonapi_resource</span> <span class="s1">'/api/employees'</span><span class="p">,</span> <span class="ss">tags: </span><span class="p">[</span><span class="s1">'employees'</span><span class="p">]</span>
</code></pre>
</div>

<p>That’s it. The suite will introspect the URL, figure out the correct
controller, introspect our DSL metadata and generate all the correct
swagger documentation. We’ll even add some extra information for you,
like which relationships can be included:</p>

<p><img src="/img/endpoints.png" alt="endpoints" />
<img src="/img/includes_filters.png" alt="endpoints" />
<img src="/img/nested_relations.png" alt="endpoints" /></p>

<p>The default actions are <code class="highlighter-rouge">create</code>, <code class="highlighter-rouge">update</code>, <code class="highlighter-rouge">index</code>, <code class="highlighter-rouge">show</code>, and
<code class="highlighter-rouge">destroy</code>. You can customize using <code class="highlighter-rouge">only</code> and <code class="highlighter-rouge">except</code>. You can also
provide a custom description per action:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">jsonapi_resource</span> <span class="s1">'/api/employees'</span><span class="p">,</span>
  <span class="ss">tags: </span><span class="p">[</span><span class="s1">'employees'</span><span class="p">],</span>
  <span class="ss">except: </span><span class="p">[</span><span class="ss">:destroy</span><span class="p">,</span> <span class="ss">:update</span><span class="p">],</span>
  <span class="ss">descriptions: </span><span class="p">{</span>
    <span class="ss">create: </span><span class="s2">"Presence of name is validated"</span>
  <span class="p">}</span>
</code></pre>
</div>

        </section>
    

    
        <section id="jsonapi-plus" class="h1">
            
                  <h1><a href="#jsonapi-plus" name="jsonapi-plus">JSON API Plus</a></h1>
                

            <p>There are times when the JSON API specification doesn’t yet support
something…but you have this use case <em>now</em> and need to get your work
done. We support a few of these scenarios in a way that is compatible
with the current specification, but not defined within it - we call this
JSON API Plus.</p>

<p>Todo</p>

        </section>
    

    



            </div>
        </div>

        <script src="/js/jquery-2.1.1.min.js"></script>
        <script scr="/js/jquery.scrollTo.js"></script>
        <script src="/js/jquery.nav.js"></script>
        <script src="/js/scripts.js"></script>
    </body>
</html>
